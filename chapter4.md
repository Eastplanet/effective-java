# 4장 클래스와 인터페이스

# 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 분리한다. <br>
오직 API로만 다른 컴포넌트와 소통한다. <br>

### 정보 은닉의 장점
- 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
- 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.
- 정보 은닉 자체가 성능을 높이지는 않지만, 성능 최적화에 도움을 준다. 
  - 숨겨져 있는 부분은 마음대로 수정해도 상관없으니 성능 최적화가 용이하다는 뜻 같음.
- 소프트웨어 재사용성을 높인다.
- 큰 시스템을 제작하는 난이도를 낮춰준다. 개발 컴포넌트의 동작을 검증할 수 있기 때문

### 기본 원칙
모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.

### 클래스, 인터페이스(private 안됨)
- public : 공개 API, 하위 호환을 위해 영원히 관리해줘야 한다.
- package-private : 패키지 안에서만 이용, 다음 릴리스에서 수정, 교체, 제거가 가능해진다.
- private static : 한 클래스에서만 사용하는 클래스는 중첩 선언

### 멤버
- private : 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
- package-private(기본값, 단 인터페이스는 기본 public) : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.
- protected : package-private + 하위 클래스에서도 접근할 수 있다.
- public : 모든 곳에서 접근할 수 있다.

공개 API를 세심히 설계한 후, 모든 멤버를 private으로 만들자. <br>
그다음 같은 패키지의 클래스가 접근해야 하는 멤버는 package-private으로 풀어주자. <br>
단, Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다. <br>
또한 public 클래스의 protected 멤버는 사실상 공개 API이므로 영원히 지원돼야 한다. <br>

### public 클래스의 인스턴스 필드는 public이 아니어야 한다.
final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다. <br>
그 필드와 관련된 모든 것은 불변식을 보장할 수 없게 되고, 필드가 수정될 때 (락 획득 등의) 다른 작업을 할 수 없게 되므로 스레드 안전하지 않다. <br>
구성요소로써 꼭 필요한 상수라면 public static final 필드로 공개해도 되지만, 반드시 기본 타입 혹은 불변 객체여야 한다. <br>
가변 객체를 참조한다면 다른 객체를 참조하지는 못하지만, 객체 자체는 수정될 수 있기 때문이다.<br>


# 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
필드를 public으로 노출하지 말고 setter를 public으로 제공하라. <br>
내부를 노출한 Dimension 클래스의 성능 문제는 오늘날까지도 해결되지 못했다. <br>
필드가 불변이더라도 API를 변경하지 않고는 표현 방식을 바꿀 수 없고, 필드를 읽을 때 부수작업을 수행할 수 없다. <br>

# 아이템 17. 변경 가능성을 최소화하라
불변 클래스는 내부 값을 수정할 수 없는 클래스다. <br>

### 클래스를 불변으로 만들기 위한 규칙
1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다. (클래스를 final, 모든 생성자를 private)
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다. 필드가 참조하는 가변 객체를 클라이언트에서 수정하는 일을 막아준다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

조금 완화된 규칙으로는 "어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다"로 세울 수 있다.

### 불변 객체의 장점
- 근본적으로 스레드 안전하다.
- 재활용이 가능하다. (BigInteger, String)
- 맵이나 집합에 담긴 값이 바뀌면 불변식이 허물어지는데, 불변 객체를 사용하면 그런 걱정이 없다.

### 불변 객체의 단점
- 값이 다르면 반드시 독립된 객체로 만들어야 한다.

BigInteger의 백만자리 비트중 1개를 바꾸려고 해도, 다시 만들어야 한다.

### 가변 동반 클래스
String의 가변 동반 클래스는 StringBuilder이다. <br>
가변 동반 클래스를 통해 매번 객체를 생성하지 않도록 해줄 수 있다.

### BigInteger, BigDecimal
위 클래스를 설계할 당시, 불변 객체가 사실상 final이어야 한다는 생각이 널리 퍼지지 않아, 두 클래스의 메서드는 모두 재정의 할
 수 있도록 설계되었고, 하위 호환성이 발목을 잡아 지금까지도 이 문제를 해결하지 못했다. <br>
신뢰할 수 없는 클라이언트로부터 BigInteger나 BigDecimal를 인스턴스로 받는다면 주의해야 한다. <br>
진짜 BigInteger인지 반드시 확인해야 한다. 신뢰할 수 없는 하위 클래스의 인스턴스라고 확인되면, 방어적으로 복사해서 사용해야 한다. <br>
<br>

# 아이템 18. 상속보다는 컴포지션을 사용하라
이 책에서의 '상속'은 구현 상속을 말한다. 인터페이스 상속과는 무관하다. <br>
상위 클래스는 릴리스마다 내부 구현이 달라질 수 있으며, 그 여파로 하위 클래스가 오동작할 수 있다. <br>
<br>
### 상속 문제를 해결하는 방법
클래스를 확장하는 대신, 새로운 클래스를 만든 뒤 private 필드로 기존 클래스의 인스턴스를 참조하게 하자. <br>
기존 클래스가 구성요소로 쓰인다는 뜻에서 Composition 이라 한다. <br>
새 클래스의 메서드들은 기존 클래스의 대응하는 메서드를 호출 해 그 결과를 반환한다. 이 방식을 전달 (forwarding)이라 하며, 새 클래스의 메서드들은 전달 메서드라 부른다. <br>
새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 기존 클래스에 새로운 메서드가 추가되더라도 영향받지 않는다.
<br>
다른 Set 인스턴스를 감싸고 있다는 뜻에서 InstrumentedSet 같은 클래스를 래퍼 클래스라 하며, 데코레이터 패턴이라고 한다. <br>
래퍼 클래스는 단점이 거의 없다. 한 가지, 래퍼 클래스가 콜백 프레임워크와는 어울리지 않는다는 점만 주의하면 된다. <br>
콜백 프레임워크에서는 자기 자신의 참조를 넘겨서 다음 호출 때 사용하도록 한다. 내부 객체는 래퍼의 존재를 모르니 자신(this)의 참조를 넘기고, <br>
콜백 때는 래퍼가 아닌 내부 객체를 호출하게 된다. 이를 SELF 문제라고 한다. <br>

